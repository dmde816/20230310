<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>javaScript</title>
    <style>

    </style>
</head>
<body>
    자바 스크립트 해보자

</body>
<!-- 스크립트 태그는 바디 밑에!
    script 태그는 javascropt 구문을 작성할 수 있게 도와주는 태그 -->
<script>
    // 스크립트 안에서는 주석은 이거랑 이거는 한줄 주석
    /* 이건데 이거는
    * / 줄내림 주석

    // 자바스크립트 변수
    // 변수는 뭘까
    // 데이터를 가르키는 주소
    // 주소를 따라가면 장소를 갈 수 있는 그곳에 데이터를 저장한
    // 번수는 저장한 데이터의 주소
    /* 주소를 알면 데잍터를 가져올 수 있다.
        변수를 선언 -> 변수에 데이터를 정의 -> 그걸 메모리에 담아둔다.
        메모리: 프로그램이 실행되는 동안 필요한 데이터와 명령어를 저장하는 곳.
        
        전원이 들어와 있는 동안 유지되는 데이터
        rem 렘: cpu가 데이터를 빠르게 접근하고 사용할 수 있는 공간.
        CPU: 처리할 데이터나 명령어를 잠시 저장하고 사용하는 용도로 사용된다.
        전원이 꺼지면 저장된 데이터가 모두 날아간다.*/

        // var와 let이 있다 둘의 공통점은 변수를 선언한다는 것이지만,
        // 차이점은 
        // 변수를 작성하는 것을 변수를 선언한다고 하는데, 밑에처럼 쓴 것
        // var는 재선언이 가능한데
        // let은 재선언이 불가능하다.

        // 그래서 var는 알고만 있고 쓰지 말고 let으로 작성하자
        // var로 작업했을 때 팀원과 같이 작업했는데 변수명이 겹치는 경우
        // 1번 팀원이 var a; 라는 변수를 선언했는데 2번이 똑같이 var a;를 선언하게 되면 
        // 1번 팀원이 사용하던 a를 사용해서 작업하던 작업물이 망가진다.

        var var1 = 1;
        // var1이라는 이름의 변수를 선언

        // 1이라는 값을 메모리에 저장하는데 var1이라는 이름으로 저장
        // 1이라는 값에 접근할 수 있도록 var1이라는 변수명을 지정.
        var var1 = 1;
        let let2;
        //이렇게 변수의 값을 안 넣고 이름만 미리 선언해 놓을 수 있다.

        let2 = 3;
        // 데이터를 활용하기 위해서 이름을 정해놓는 것이다. let이나 var를 사용하자 가능하면 let으로

        // 먼저 선언을 해두고 나중에 밑에다가 값을 넣을 수 있다.

        // 자바스크립트에서 변수를 선언할 때 let이나 var 같은 선언문(키워드)을 꼭 사용해 주어야 한다.
        // 가끔가다 
        let = 3; 
        // 이렇게 변수를 사용할 떄가 있는데(실수로)
        // 이러면 전역변수로 선언이 되고 예상치못한 문제가 발생한다. (스코크 개념 들어가면 자세히 설명할 것이다)

        // html 상에서 변수를 로그로 학인해보자
        console.log(let2);
        // console.log("브라우저 개발자 모드 콘솔 창에 보여줄 값")

        // 문자는 저장할 수 없나?
        let let4 = "3";
        console.log(let4);
        // 사용할 수 있다
        // 숫자는 파란색 글자는 검정색

        // typeof 타입검사
        console.log(typeof let4);

        // 변수에 저장되는 데이터는 타입이 있는데
        // 숫자는 number
        // 문자는 string
        // 두 타입만 있는가? 더 있다.
        
        let let5 = true;
        let let6 = false;
        //  참과 거짓. 전등 스위치처럼 맞다 틀리다로 값이 필요할 때 사용
        //  boolean타입이다.
        console.log(typeof let5);

        let let7;
        console.log(let7);
        // 아무것도 없고 값만 선언 됐을 때 undefined 타입
        // 값이 없을 떄, 값이 부재일 때 값이 확인이 되지 않을 때 나타나는 타입
        // 값을 넣지 않고 선언했을 떄 자동으로 들어가는 데이터 타입

        let let8 = null;
        // undefined와 같이 값이 없음을 나타내는 데이터 타입
        // 개발자가 변수에 값이 없음을 나타낼 떄 작성해 놓는 값이다. 의도적으로 나타낼 때 (얘는 값을 일부러 비워놓은 거야)

        // 타입 두가지가 더 있긴 함.

        // 변수는 바이트를 가지고 있고, 타입들이 있고, 선언을 할 수 있다.
        // 변수의 작성과 타입만 알면 된다.

        // 밑에 건 외울 필요는 없다. 
        // 데이터의 byte
        // 숫자 타입 : 8바이트
        // 문자열 : 문자의 길이에 따라 다르긴 한데, 대략 2바이트 이상의 크기
        // true false (boolean) : 1바이트 (true, false 둘 중 하나가 나타나니까)
        // mull : 0바이트
        // undefined : 0바이트
        // 나중에 블록체인 들어가서 
        // 바이트 패딩 기법을 볼 수 있는데
        // 이런 바이트(데이터)를 전송하거나 저장할 때
        // 일정한 크기의 블록으로 나누어서 각 블록의 크기를 일정하게 맞춰서 사용하기 떄문
        // 바이트 패딩 기법이 있는 이유는 데이터를 전송할 떄 보안성이나 속도를 향상 시킬 수 있기 때문에
        // 공부할 필요는 없다. 어렵다.
        //  블록 들어갔을 떄 암호화라던가 sha-256이라는 데이터를 암호화를 시켜주는 착한 아이가 있어요 함수
        
        // 오늘 집에가서는 변수가 손에 익을 때까지 100번 써보기

        // 간단히 let이라는 선언문으로 type1이라는 이름의 변수를 만들고 값 넣지말고 선언만 하고
        // 그 밑에 console.log() 로 type1 변수의 값을 확인하고 
        // 값을 확인한 뒤에 그 밑에 작성하는데 5라는 값을 대입하고
        // 다시 console.log()로 확인
        // 그 다음에 console.log() typeof로 타입을 확인하고
        // 밑에 "본인 이름"을 type1변수에 대입
        // 마지막으로 console.log() 확인

        let type1;
        console.log(type1);

        type1 = 5;
        console.log(type1);

        console.log(typeof type1);

        type1 = "이름";
        console.log(type1);

        // 변수는 변할 수 있는 값이다. 5에서 이름으로 값이 변했듯이

        // string, number, bool, undefined, null 이렇게가 원시(기초) 타입
        // 타입이 더 있다. 래퍼런스 타입.

        // object 객체타입
        // 얘는 사람을 치면 사람의 기능? 들을 한번에 나열할 수 있게 하는 것
        // 사람의 이름, 성별, 나이, ... 를 한 번에 모아서 한 사람(object)가 되는 것
        // 객체타입은{} 로 정의
        let obj = {a:1, b:2, c:3};
        // obj에 객체의 a값을 대입하거나 가져오려면
        //  .으로 객체의 값에 접근할 수 있다.
        console.log("obj : a : ",obj.a);
        console.log("obj : b : ",obj.b);
        console.log("obj : c : ",obj.c);
        // 객체의 키값 a, b, c 

        obj.a = 10;

        // 추가로 키값(d)을 추가하고 20이라는 값을 해당 키값에 저장.
        obj.d = 20;
        // 객체에 있는 a에 10이라는 값을 대입하는 것

        // 배열타입
        // 얘는 단순 나열인 것
        // 합쳐서 어떤 덩어리가 되는 것이 아니고
        // 그냥 집합..?
        // [] 로 정의, 숫자와 문자 모두 나열할 수 있다.
        let arr = [1,2,3,"1","2","3"];
        // 배열의 인덱스는 0
        // 배열의 값의 순서는 (0~ 배열의 길이 -1)
        // 배열에 들어있는 값을 6개인데 
        // 순서가 0부터 시작하니까
        // 배열의 순서는 0번 부터 5번까지 있는 것 0~5
        // 배열의 인덱스라고 부른다. 0~5를

        arr[0];
        // 리스트에서 1번의 값을 가져오고 싶으면
        console.log(arr[0])
        console.log("arr[1] : ",arr[1])
        console.log("arr[2] : ",arr[2])
        console.log("arr[3] : ",arr[3])
        //  배열에 값 추가
        // 지금 배열에 있는 리스트들 값의 맨 뒤에 새로운 값이 추가된다.
        arr.push("4");

        // object, array : 래퍼런스타입

        console.log(obj);
        console.log(arr);

        // 변수의 이름을 작성하는 방법은 여러가지가 있는데,
        // 표기법
        // 이거는 회사가서 사수가 사용하고 있는 표기법으로 사용하면 된다. 사수가 없으면 본인이 정하면 됨

        // 케밥표기법
        // kebab case
        // let item-box // CSS class 이름 같은 것
        // 이런 식으로 css에 스타일 작성할 떄 썼던 것처럼

        // 카멜 표기법 낙타 표기법이라고도 부른다. (제일 많이 쓰긴 한다.)
        // 자바스크립트 변수명을 선언할 때 자주 사용하는 표기법
        let itemBox;
        // 낙타 등처럼 올라와서 낙타 표기법
        // 구분되는 곳에 대문자를 써서 표기하는 것 (B)

        // 스네이크 표기법, 뱀 표기법
        let item_box;

        // 헝가리안 표기법, 사용도가 조금 떨어져요..
        let strItemBox;
        // 타입(문자, 숫자 등)을 정해주고 변수명에 작성함.

        // 파스칼 표기법 (나중에 react에 들어가서 보게 될 것 컴포넌트라는 것 할 때)
        let ItemBox;

        // 수치를 가지고 값을 가지고
        // 할 수 있는 게 뭐가 있지?
        // 숫자끼리 뺴고 더하고 붙이고 할 건데
        // 연산자 (연산할 때 사용하는)
        // +, -, *, /, %(나머지 값)
        // +: 더하기
        let a = 3;
        let b = 3;
        // 값을 가져오고 싶을 땐 a와 b를 작성한 것처럼 변수의 이름을 적어주면 
        // 해당 변수명으로 저장된 값을 가져올 수 있다.
        let c = a + b;
        console.log(c);

        let text1 = "나는 ";
        let text2 = "배고프다";
        // 문자열을 +로 더해서 하나의 문자열로 합쳐줬다.
        console.log(text1 + text2);

        console.log(a-b);
        console.log(a*b);
        console.log(a/b);
        console.log(a%b);


        // 연산자는 외워야 한다.
        // 연산자 중에
        // ++, --, ** 도 있다.
        // 3에서 ++ 연산자를 사용해서 1의 값이 증가한 4의 값을 보임.
        // ++은 1의 값 증가

        a++;
        console.log(a);
        // ++로 증가한 4의 값에서 1이 감소된 3의 값을 보임.
        
        a--;
        console.log(a);

        

        // ++이나 -- 같은 경우에는 변수의 값이 변하는데
        // a + 1; 이렇게 쓴다고 변수의 값이 변하진 않는다. 콘솔에만 그렇게 보이는 것
        // 다음에 쓸 때는 또 a = a +1;을 또 써줘야하는데
        // ++하고 나면 그 값이 변해서 다음엔 숫자가 변해져 있는 것

        let test1 = 1;
        // console.log(test1 + 1);
        test1 = test1 + 1;
        console.log(test1);

        // a 변수에 값을 대입하는데 a의 3 제곱의 값을 대입한다.
        a = a ** 3;
        console.log(a);

        console.log(a * 2);

        console.log(a * 3);
        


        // 비교하는 연산자
        //  !, ==, ===, !=, !==, >, <

        let test2 = true;
        let test3 = true;
        console.log(!test3);
        // !를 붙이면 bool값을 반전시킨다.

        let test4 = 2;
        let test5 = 3;
        console.log(test4 == test5);
        // test2와 test3 두 값이 같은지를 물어보는 것
        // 같으면 true 값, 다르면 false값

        // let test4 = 2;
        // let test5 = "2";
        // console.log(test4 == test5);
        // 이것은  ==으로 하면 트루로 나옴 type을 고려하지 않기 때문에

        //  ===은 좀 더 비교를 정밀하게 확실하게 비교하는 연산자
        //  ==은 값만 비교를 했지만, ===은 type까지도 비교해주는 친구
        console.log(test4 === test5);
        // 이거는 타입이 다르기 때문에 ===으로 하면 false가 나옴.
        // let test4 = 2;
        // let test5 = 2;
        // 이렇게 해야 똑같다 true가 나옴

        console.log(test4 != test5);
        // 같은지 비교를 하고 값을 반대로 보여줌
        // 숫자가 다르면 true를 보여줌
        // 숫자가 같으면 false

        // 같은지 비교를 하는데 타입까지 더 확실하게 비교하는 연산자
        console.log(test4 !== test5);
        // ===의 반대로 표줄되는 것

        let test6 = 3;
        let test7 = 5;
        console.log(test6 > test7);
        // 값이 큰지 작은지 확인을 하는데
        // 부등호 방향으로 값이 
        // 크면 true
        // 작으면 false

        console.log(test6 < test7);
        // true가 나와야 겠지

        // ><로 같은 값을 입력하면 둘 다 false가 나온다. 그럼 뭐가 더 큰지 알 수가 없는 것
        // ><는 초과 미만이어서 비교하는 값보다 초과나 미만이어야 한다.

        //  비교연산자에 >=, <=가 또 있다. =은 꼭 뒤에다가 쓰는 것
        // 이상과 이하의 값

        console.log(test6 <= test7);
        // test6 보다 test7이 값이 크거나 같을 때

        console.log(test6 >= test7);
        // test6 보다 test7이 값이 작거나 같을 때

    





</script>
</html3>